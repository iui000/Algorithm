package GinkgoStack.P23_ArtConcurrentBook.chapter08;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest {    static CyclicBarrier c = new CyclicBarrier(2);    public static void main(String[] args) {        /**         * 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种 输出，         */        new Thread(new Runnable() {            @Override            public void run() {                try {                    //每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞                    c.await();                } catch (Exception e) {                }                System.out.println(1);            }        }).start();        try {            //每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞            c.await();        } catch (Exception e) {        }        System.out.println(2);    }}