package GinkgoStack.P20_DynamicProgramming.GameTypeDP;

/**
 * 1140. 石子游戏 II
 * 亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，
 * 每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。
 *
 * 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。
 *
 * 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。
 *
 * 游戏一直持续到所有石子都被拿走。
 *
 * 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。
 *
 *
 *
 * 示例：
 *
 * 输入：piles = [2,7,9,4,4]
 * 输出：10
 * 解释：
 * 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。
 * 在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。
 *
 * 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。
 * 在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。
 * 所以我们返回更大的 10。
 *
 *
 * 提示：
 *
 * 1 <= piles.length <= 100
 * 1 <= piles[i] <= 10 ^ 4
 */
public class StoneGameII1140 {

    /**
     * 思路
     *
     * 首先，这是比较明显的博弈型DP，先手做出选择后，后手也会按照最优策略来做决策，
     * 从后手的角度来考虑问题时，他必须要直接或间接让对手获得的利益最小，从而让自己的利益最大化。
     * 其次，DP问题一般是从后往前推，考虑状态与哪些量有关，从而定义dp数组含义。
     * ● 一方面，一定要存储的是取到某一个位置i时，[0...i]之间已经得到的最大值 或者 后面[i...end]能得到的最大值.
     * ● 另一方面，光有位置i是不够的，还要决定在该起始位置之后取多少堆石头（记为x），所以还需存储当前的M值，来限定x的取值范围。
     * 如：假如最后只剩一堆，一定能算出来最佳方案。
     *
     * 状态转移方程
     * dp[i][j]表示剩余[i : len - 1]堆时，M = j的情况下，能获得的最多石子数，
     * 并不针对先手和后手，到了谁的回合，就表示M = j的情况下该玩家能从piles[i : len - 1]中获得的最多石子数量。
     *
     * 下面枚举状态的不同情况：
     * 第一种情况：i + 2M >= len, 说明剩下的堆数能够直接全部取走，那么最优的情况就是剩下的石子总和： dp[i][M] = sum[i : len - 1]。
     * 第二种情况：i + 2M < len, 说明剩下的堆数该玩家不能全部取走，现在开始用博弈型DP的常规套路：
     * 假设现在该玩家(记作玩家1)已经做出决策（在这个题目中，决策是指 以下标i作为起始位置选定x堆石头），
     * 然后接着要换到另外一个玩家(记作玩家2)的角度（回合）来思考问题，玩家2也要用最优的策略来做出选择，
     * 让自己利益最大化，具体实现就是：要么让玩家1的利益最小间接地让自己利益最大，要么让直接取子问题的最大利益，都一个意思，只是不同题目有不同的具体实现方式。
     * 对于这道题，前面已经定义了dp[i][j]的含义，因此玩家2可以用直接的方式：取dp[i + x][max(M, x)]，
     * 表示他能从i + x为起始位置，M = max(M, x)的情况下获得的最大利益。
     * 自然而然，对于特定的x，也就达到了让玩家1的利益最小：sum[i : len - 1] - dp[i + x][max(M, x)]。
     * 最终，玩家1的最大利益就是迭代x,并找到最大的dp[i][M] = max(dp[i][M], sum[i : len - 1] - dp[i + x][max(M, x)]), 其中 1 <= x <= 2M。
     */
    class Solution {
        //时间复杂度O（n^3）
        public int stoneGameII(int[] piles) {
            int n = piles.length, sumiToN = 0;
            int[][] dp = new int[n][n + 1];

            //从后往前考虑位置i
            for (int i = n - 1; i >= 0; i--) {
                sumiToN += piles[i];
                for (int M = 1; M <= n; M++) {
                    if (i + 2 * M >= n) {
                        dp[i][M] = sumiToN;
                    } else {
                        for (int x = 1; x <= 2 * M; x++) {
                            //玩家2可以用直接的方式：取dp[i + x][max(M, x)]最大
                            //玩家1自然就只能sumiToN - dp[i + x][Math.max(M, x)]
                            dp[i][M] = Math.max(dp[i][M], sumiToN - dp[i + x][Math.max(M, x)]);
                        }
                    }
                }
            }
            return dp[0][1];
        }
    }
}
